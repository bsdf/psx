// generated by Fast Light User Interface Designer (fluid) version 1.0110

#include "FreeEditUI.h"
#include <FL/Fl_File_Chooser.H>
#include<sys/stat.h>
#include <stdio.h>
#include <string>
#include <math.h>

FreeEditUI::FreeEditUI(int x,int y, int w, int h, const char *label):Fl_Box(x,y,w,h,label) {
  max_value_fl=min_value_fl=value_fl=position_fl=NULL;
free_edit=NULL;
control=NULL;

current_point=-1;
selected_point=-1;

default_value=1.0;
}

FreeEditUI::~FreeEditUI() {
}

void FreeEditUI::init(FreeEdit *free_edit_,Control *control_) {
  free_edit=free_edit_;
control=control_;
free_edit->update_curve();
}

void FreeEditUI::init_value_io(Fl_Value_Input *value_fl_,Fl_Value_Input *position_fl_,Fl_Value_Input *min_value_fl_,Fl_Value_Input *max_value_fl_) {
  value_fl=value_fl_;
position_fl=position_fl_;
min_value_fl=min_value_fl_;
max_value_fl=max_value_fl_;

if (free_edit){
	free_edit->extreme_y.set_min(min_value_fl->value());
	free_edit->extreme_y.set_max(max_value_fl->value());
};
}

Fl_Color FreeEditUI::get_color(Fl_Color c) {
  if (free_edit->get_enabled()) return c;

return fl_color_average(c,fl_rgb_color(178,178,178),0.1);
}

void FreeEditUI::draw() {
  int ox=x(),oy=y(),lx=w(),ly=h();

//fl_color(FL_WHITE);
fl_color(get_color(color()));
fl_rectf(ox,oy,lx,ly);

//fl_color(FL_GRAY);
fl_color(get_color(labelcolor()));
//draw grid
fl_line_style(FL_SOLID);
for (int ncoord=0;ncoord<2;ncoord++){
	FreeEditExtremes *extreme=(ncoord==0)?&free_edit->extreme_x:&free_edit->extreme_y;
	if (extreme->get_scale()==FE_LOG){//logarithmic scale
		float p10=pow(10,floor(log10(extreme->get_min())));
		int psteps=(int)(floor(log10(extreme->get_max()/extreme->get_min())))+1;
		for (int k=1;k<=psteps;k++){
			for (int i=1;i<10;i++){
				if (i==1) fl_line_style(FL_SOLID);
				else if(i==5) fl_line_style(FL_DASH);
					else  fl_line_style(FL_DOT);
				float fpos=extreme->real_value_to_coord(p10*i);
				if ((fpos>0.0)&&(fpos<1.0)){
					if (ncoord==0){
						int pos=(int)(fpos*lx);
						fl_line(ox+pos,oy,ox+pos,oy+ly);
					}else{
						int pos=(int)(ly-1-fpos*ly);
						fl_line(ox,oy+pos,ox+lx,oy+pos);
					};
				};
			};
			p10*=10.0;
		};
	}else{//linear scale
		float diff=extreme->get_max()-extreme->get_min();
		float stepsize=pow(10,floor(log10( fabs(diff))))*0.1;
		if (stepsize>=1e-6){
			int nsteps=(int)(fabs(diff)/stepsize)+1;
			if (nsteps>25) {
				nsteps/=5;
				stepsize*=5.0;
			};
			float min=extreme->get_min();
			float max=extreme->get_max();
			float min1=(min<max)?min:max;
			int kstep=(int)(floor(min1/stepsize));
			min1=kstep*stepsize;
			for (int i=0;i<nsteps;i++){
				float fpos=extreme->real_value_to_coord(min1+i*stepsize);
				int ks=(i+kstep)%10; if (ks<0) ks+=10;
				if (ks==0) fl_line_style(FL_SOLID);
				else if (ks==5) fl_line_style(FL_DASH);
					else  fl_line_style(FL_DOT);
				if ((fpos>0.0)&&(fpos<1.0)){
					if (ncoord==0){
						int pos=(int)(fpos*lx);
						fl_line(ox+pos,oy,ox+pos,oy+ly);
					}else{
						int pos=(int)(ly-1-fpos*ly);
						fl_line(ox,oy+pos,ox+lx,oy+pos);
					};
				};
			};
		};
	};
};



//draw the line
fl_line_style(FL_SOLID,2);
fl_color(get_color(labelcolor()));
float *data=new float[lx];


free_edit->get_curve(lx,data,false);
int oldy=0;
for (int i=0;i<lx;i++){
	int newy=(int)((1.0-data[i])*ly);
	if (i) fl_line(ox+i-1,oy+oldy,ox+i,oy+newy);
	oldy=newy;
};

delete[]data;

//draw points
fl_line_style(FL_SOLID,3);
for (int i=0;i<free_edit->get_npoints();i++){
	if (!free_edit->is_enabled(i)) continue;
	fl_color(FL_BLACK);
	int x=(int)(free_edit->get_posx(i)*lx);
	int y=(int)((1.0-free_edit->get_posy(i))*ly);
	fl_circle(ox+x,oy+y,3);
	if (i==selected_point){
		fl_color(get_color(FL_RED));
		fl_circle(ox+x,oy+y,4);
		fl_circle(ox+x,oy+y,5);
	};
};


/*
//test
{
fl_color(FL_RED);
fl_line_style(FL_SOLID);

free_edit->update_curve();

int oldy=0;
//printf("draw %g\n",free_edit->get_value(8000.0));
//printf("d %g\n",free_edit->curve.data[1000]);

for (int i=0;i<lx;i++){
	//int m=(int)(((float)i/(float)lx)*(free_edit->curve.size-1));
	//REALTYPE y=free_edit->curve.data[m];
	REALTYPE freq=i/(float)lx*25000.0;
	REALTYPE y=free_edit->get_value(freq);
	//if (i<20) printf("%d %g\n",i,y);
	//printf("%g %g\n",freq,y);


	int newy=(int)((1.0-y)*ly);

	if (i) fl_line(ox+i-1,oy+oldy,ox+i,oy+newy);
	oldy=newy;
};
};
*/




/*


fl_color(FL_RED);
fl_line_style(FL_SOLID);


	int samplerate=44100;
	

	int nfreq=lx;
	float *freq1=new float [nfreq];
	float *freq2=new float [nfreq];	
	float *tmpfreq1=new float [nfreq*2];

                for (int i=0;i<nfreq;i++) tmpfreq1[i]=0.0;

	for (int i=0;i<nfreq;i++) freq1[i]=data[i];

        //convert to log spectrum
        
        float minfreq=20.0;
        float maxfreq=0.5*samplerate;
       for (int i=0;i<nfreq;i++){
        	float freqx=i/(float) nfreq;
        	float x=exp(log(minfreq)+freqx*(log(maxfreq)-log(minfreq)))/maxfreq*nfreq;
        	float y=0.0;
        	int x0=(int)floor(x); if (x0>=nfreq) x0=nfreq-1;
        	int x1=x0+1; if (x1>=nfreq) x1=nfreq-1;
        	float xp=x-x0;
        	if (x<nfreq){
        		y=freq1[x0]*(1.0-xp)+freq1[x1]*xp;
        	};
        	tmpfreq1[i]=y;
        };
    
    
       //increase bandwidth of each harmonic
        int n=2;
	float bandwidth=free_edit->get_posy(0);
	float a=1.0-exp(-bandwidth*bandwidth*nfreq*0.002);
	a=pow(a,n);
	printf("%g\n",a);

        for (int k=0;k<n;k++){                                                  
                tmpfreq1[0]=0.0;
                for (int i=1;i<nfreq;i++){                                       
                        tmpfreq1[i]=tmpfreq1[i-1]*a+tmpfreq1[i]*(1.0-a);
                };                                                              
                tmpfreq1[nfreq-1]=0.0;                                               
                for (int i=nfreq-2;i>0;i--){                                     
                        tmpfreq1[i]=tmpfreq1[i+1]*a+tmpfreq1[i]*(1.0-a);                    
                };                                                              
        };                                                                      

        //convert back to linear spectrum
//        for (int i=0;i<nfreq;i++) freq2[i]=0.0;
//        for (int i=0;i<nfreq;i++) freq2[i]=tmpfreq1[i];

	freq2[0]=0;
        for (int i=1;i<nfreq;i++){
        	float freqx=i/(float) nfreq;
        	float x=log((freqx*maxfreq)/minfreq)/log(maxfreq/minfreq)*nfreq;
//        	printf("%g\n",x);
        	float y=0.0;
        	int x0=(int)floor(x); if (x0>=nfreq) x0=nfreq-1;
        	int x1=x0+1; if (x1>=nfreq) x1=nfreq-1;
        	float xp=x-x0;
        	if (x<nfreq){
        		y=tmpfreq1[x0]*(1.0-xp)+tmpfreq1[x1]*xp;
        	};
        	freq2[i]=y;
        };

        


        
for (int i=0;i<lx;i++){
	
	REALTYPE y=freq2[i];

	int newy=(int)((1.0-y)*ly);


	if (i) fl_line(ox+i-1,oy+oldy,ox+i,oy+newy);
	oldy=newy;
};
       
        delete [] freq1;
        delete [] freq2;
        delete [] tmpfreq1;
//        delete [] tmpfreq2;
*/
}

int FreeEditUI::handle(int event) {
  if (!free_edit->get_enabled()) return Fl_Box::handle(event);

int ox=x(),oy=y(),lx=w(),ly=h();
float px=(Fl::event_x()-ox)/(float)lx;
float py=1.0-(Fl::event_y()-oy)/(float)ly;
if (px<0) px=0;
	else if (px>1.0) px=1.0;
if (py<0) py=0;
	else if (py>1.0) py=1.0;

int closest=-1;
float xyrap=(float)ly/(float)lx;
for (int i=0;i<free_edit->get_npoints();i++){
	if (!free_edit->is_enabled(i)) continue;
	float d=pow(px-free_edit->get_posx(i),2)+pow(py-free_edit->get_posy(i),2)*xyrap;
	if (d<0.0005) {
		closest=i;
		break;
		
	};
};


if (event==FL_PUSH){
	if (closest>=0) {
		if (Fl::event_button()==1) selected_point=current_point=closest;
		if ((Fl::event_button()==3)&&(closest>=2)) {
			free_edit->set_enabled(closest,false);
			current_point=selected_point=-1;
		};
	}else{
		for (int i=0;i<free_edit->get_npoints();i++){
			if (!free_edit->is_enabled(i)){
				selected_point=closest=current_point=i;
				free_edit->set_posx(current_point,px);
				free_edit->set_posy(current_point,py);
				free_edit->set_enabled(i,true);				
				break;
			};
		};		
	};
	refresh_value();
	redraw();
	update_curve();
	return true;
};
if (event==FL_RELEASE){
	current_point=-1;
	refresh_value();
	update_curve();
	if (control) control->update_process_parameters();
	return true;
};

if (event==FL_DRAG){
	if (current_point>=0){
		if (current_point>=2) free_edit->set_posx(current_point,px);
		free_edit->set_posy(current_point,py);
		redraw();
	};
	refresh_value();
	update_curve();
	return true;
};

return Fl_Box::handle(event);
}

void FreeEditUI::refresh_value() {
  if (!value_fl) return;
value_fl->deactivate();
position_fl->deactivate();
if (selected_point<0) return;
if (!free_edit->is_enabled(selected_point)) return;
value_fl->activate();
position_fl->activate();

float val=free_edit->extreme_y.coord_to_real_value(free_edit->get_posy(selected_point));
val=((int)(val*10000.0))/10000.0;
value_fl->value(val);


float pos=free_edit->extreme_x.coord_to_real_value(free_edit->get_posx(selected_point));
pos=((int)(pos*1000.0))/1000.0;
position_fl->value(pos);
}

void FreeEditUI::set_selected_value(float val) {
  if (!value_fl) return;
if (selected_point<0) return;
if (!free_edit->is_enabled(selected_point)) return;

free_edit->set_posy(selected_point,free_edit->extreme_y.real_value_to_coord(val));
redraw();
update_curve();
}

void FreeEditUI::set_selected_position(float pos) {
  if (!value_fl) return;
if (selected_point<0) return;
if (!free_edit->is_enabled(selected_point)) return;

free_edit->set_posx(selected_point,free_edit->extreme_x.real_value_to_coord(pos));
redraw();
update_curve();
}

void FreeEditUI::set_min_value(float val) {
  unselect();

free_edit->extreme_y.set_min(val);
redraw();
update_curve();
}

void FreeEditUI::set_max_value(float val) {
  unselect();

free_edit->extreme_y.set_max(val);
redraw();
update_curve();
}

void FreeEditUI::unselect() {
  selected_point=-1;
refresh_value();
redraw();
}

void FreeEditUI::set_smooth(float smooth) {
  free_edit->set_smooth(smooth);
redraw();
update_curve();
}

void FreeEditUI::set_interp_mode(int interp_mode) {
  free_edit->set_interp_mode((FreeEdit::INTERP_MODE)interp_mode);
redraw();
update_curve();
}

void FreeEditUI::clear() {
  for (int i=2;i<free_edit->get_npoints();i++) free_edit->set_enabled(i,false);
free_edit->set_all_values(default_value);
redraw();
update_curve();
}

void FreeEditUI::update_curve() {
  free_edit->update_curve();
}

void FreeEditControls::cb_free_edit_min_value_fl_i(Fl_Value_Input* o, void*) {
  free_edit_ui->unselect();
free_edit_ui->set_min_value(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_min_value_fl(Fl_Value_Input* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_min_value_fl_i(o,v);
}

void FreeEditControls::cb_free_edit_max_value_fl_i(Fl_Value_Input* o, void*) {
  free_edit_ui->unselect();
free_edit_ui->set_max_value(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_max_value_fl(Fl_Value_Input* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_max_value_fl_i(o,v);
}

void FreeEditControls::cb_free_edit_value_fl_i(Fl_Value_Input* o, void*) {
  free_edit_ui->set_selected_value(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_value_fl(Fl_Value_Input* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_value_fl_i(o,v);
}

void FreeEditControls::cb_free_edit_smooth_i(Fl_Roller* o, void*) {
  free_edit_ui->set_smooth(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_smooth(Fl_Roller* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_smooth_i(o,v);
}

void FreeEditControls::cb_free_edit_interpolate_i(Fl_Choice* o, void*) {
  free_edit_ui->set_interp_mode(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_interpolate(Fl_Choice* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_interpolate_i(o,v);
}

Fl_Menu_Item FreeEditControls::menu_free_edit_interpolate[] = {
 {"Linear", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"Cosine", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void FreeEditControls::cb_clear_i(Fl_Button*, void*) {
  if (!fl_choice("Delete all points?","No","Yes",NULL)) return;
free_edit_ui->clear();
update_parameters();
}
void FreeEditControls::cb_clear(Fl_Button* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_clear_i(o,v);
}

void FreeEditControls::cb_enabled_check_i(Fl_Light_Button* o, void*) {
  free_edit_ui->free_edit->set_enabled(o->value());
free_edit_ui->update_curve();
free_edit_ui->redraw();
update_parameters();
}
void FreeEditControls::cb_enabled_check(Fl_Light_Button* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_enabled_check_i(o,v);
}

void FreeEditControls::cb_free_edit_position_fl_i(Fl_Value_Input* o, void*) {
  free_edit_ui->set_selected_position(o->value());
update_parameters();
}
void FreeEditControls::cb_free_edit_position_fl(Fl_Value_Input* o, void* v) {
  ((FreeEditControls*)(o->parent()->parent()->user_data()))->cb_free_edit_position_fl_i(o,v);
}

FreeEditControls::FreeEditControls(int x,int y, int w, int h, const char *label):Fl_Group(x,y,w,h,label) {
  free_edit_ui=NULL;
}

FreeEditControls::~FreeEditControls() {
  hide();
}

void FreeEditControls::init(FreeEditUI *free_edit_ui_,FREE_EDIT_EXTREME_SCALE scale_x,float min_x,float max_x,FREE_EDIT_EXTREME_SCALE scale_val,float min_val,float max_val,float default_value) {
  free_edit_ui=free_edit_ui_;

make_window();
end();

free_edit_ui->init_value_io(free_edit_value_fl,free_edit_position_fl,free_edit_min_value_fl,free_edit_max_value_fl);
feui->resize(this->x(),this->y(),this->w(),this->h());

FreeEdit *fe=free_edit_ui->free_edit;

fe->extreme_x.set_min(min_x);
fe->extreme_x.set_max(max_x);
fe->extreme_x.set_scale(scale_x);

fe->extreme_y.set_min(min_val);
fe->extreme_y.set_max(max_val);
fe->extreme_y.set_scale(scale_val);

free_edit_min_value_fl->value(min_val);
free_edit_max_value_fl->value(max_val);
free_edit_ui->default_value=default_value;
fe->set_all_values(default_value);

enabled_check->value(fe->get_enabled());
}

void FreeEditControls::update_parameters() {
  if (free_edit_ui->control) free_edit_ui->control->update_process_parameters();
}

Fl_Group* FreeEditControls::make_window() {
  { feui = new Fl_Group(0, 0, 85, 210);
    feui->box(FL_FLAT_BOX);
    feui->color((Fl_Color)FL_LIGHT1);
    feui->selection_color((Fl_Color)FL_BACKGROUND_COLOR);
    feui->labeltype(FL_NO_LABEL);
    feui->labelfont(1);
    feui->labelsize(14);
    feui->labelcolor((Fl_Color)FL_FOREGROUND_COLOR);
    feui->user_data((void*)(this));
    feui->align(FL_ALIGN_TOP);
    feui->when(FL_WHEN_RELEASE);
    { Fl_Group* o = new Fl_Group(0, 0, 85, 210);
      o->box(FL_PLASTIC_THIN_UP_BOX);
      o->color((Fl_Color)FL_LIGHT2);
      o->labeltype(FL_ENGRAVED_LABEL);
      o->labelsize(10);
      o->align(FL_ALIGN_CENTER);
      { free_edit_min_value_fl = new Fl_Value_Input(5, 110, 50, 15, "Val.Min");
        free_edit_min_value_fl->labelsize(10);
        free_edit_min_value_fl->minimum(-10000);
        free_edit_min_value_fl->maximum(10000);
        free_edit_min_value_fl->textfont(1);
        free_edit_min_value_fl->textsize(10);
        free_edit_min_value_fl->callback((Fl_Callback*)cb_free_edit_min_value_fl);
        free_edit_min_value_fl->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Input* free_edit_min_value_fl
      { free_edit_max_value_fl = new Fl_Value_Input(5, 140, 50, 15, "Val.Max");
        free_edit_max_value_fl->labelsize(10);
        free_edit_max_value_fl->minimum(-10000);
        free_edit_max_value_fl->maximum(10000);
        free_edit_max_value_fl->value(1);
        free_edit_max_value_fl->textfont(1);
        free_edit_max_value_fl->textsize(10);
        free_edit_max_value_fl->callback((Fl_Callback*)cb_free_edit_max_value_fl);
        free_edit_max_value_fl->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Input* free_edit_max_value_fl
      { free_edit_value_fl = new Fl_Value_Input(5, 75, 70, 15, "Value");
        free_edit_value_fl->labelfont(1);
        free_edit_value_fl->labelsize(10);
        free_edit_value_fl->minimum(0.03);
        free_edit_value_fl->maximum(100);
        free_edit_value_fl->value(0.5);
        free_edit_value_fl->textfont(1);
        free_edit_value_fl->textsize(10);
        free_edit_value_fl->callback((Fl_Callback*)cb_free_edit_value_fl);
        free_edit_value_fl->align(FL_ALIGN_TOP_LEFT);
        free_edit_value_fl->deactivate();
      } // Fl_Value_Input* free_edit_value_fl
      { free_edit_smooth = new Fl_Roller(60, 110, 15, 45, "Sm");
        free_edit_smooth->tooltip("Smooth function");
        free_edit_smooth->labelsize(10);
        free_edit_smooth->minimum(1);
        free_edit_smooth->maximum(0);
        free_edit_smooth->step(0.01);
        free_edit_smooth->callback((Fl_Callback*)cb_free_edit_smooth);
        free_edit_smooth->align(FL_ALIGN_TOP);
        free_edit_smooth->when(FL_WHEN_RELEASE);
      } // Fl_Roller* free_edit_smooth
      { free_edit_interpolate = new Fl_Choice(5, 170, 70, 15, "Interpolate");
        free_edit_interpolate->down_box(FL_BORDER_BOX);
        free_edit_interpolate->labelsize(11);
        free_edit_interpolate->textfont(1);
        free_edit_interpolate->textsize(10);
        free_edit_interpolate->callback((Fl_Callback*)cb_free_edit_interpolate);
        free_edit_interpolate->align(FL_ALIGN_TOP_LEFT);
        free_edit_interpolate->menu(menu_free_edit_interpolate);
      } // Fl_Choice* free_edit_interpolate
      { Fl_Button* o = new Fl_Button(5, 190, 75, 15, "clear");
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_clear);
      } // Fl_Button* o
      { enabled_check = new Fl_Light_Button(5, 5, 75, 20, "Enable");
        enabled_check->color((Fl_Color)FL_BACKGROUND2_COLOR);
        enabled_check->selection_color((Fl_Color)FL_RED);
        enabled_check->labelfont(1);
        enabled_check->callback((Fl_Callback*)cb_enabled_check);
      } // Fl_Light_Button* enabled_check
      { free_edit_position_fl = new Fl_Value_Input(5, 45, 70, 15, "Position");
        free_edit_position_fl->labelsize(10);
        free_edit_position_fl->minimum(0.0001);
        free_edit_position_fl->maximum(10000);
        free_edit_position_fl->value(1);
        free_edit_position_fl->textfont(1);
        free_edit_position_fl->textsize(10);
        free_edit_position_fl->callback((Fl_Callback*)cb_free_edit_position_fl);
        free_edit_position_fl->align(FL_ALIGN_TOP_LEFT);
        free_edit_position_fl->deactivate();
      } // Fl_Value_Input* free_edit_position_fl
      o->end();
    } // Fl_Group* o
    feui->end();
  } // Fl_Group* feui
  return feui;
}

void FreeEditControls::refresh() {
  enabled_check->value(free_edit_ui->free_edit->get_enabled());

free_edit_min_value_fl->value(free_edit_ui->free_edit->extreme_y.get_min());
free_edit_max_value_fl->value(free_edit_ui->free_edit->extreme_y.get_max());
free_edit_interpolate->value(free_edit_ui->free_edit->get_interp_mode());
free_edit_smooth->value(free_edit_ui->free_edit->get_smooth());

free_edit_ui->update_curve();
free_edit_ui->redraw();
update_parameters();
}
